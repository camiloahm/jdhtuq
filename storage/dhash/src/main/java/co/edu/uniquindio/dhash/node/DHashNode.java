/*
 *  DHash project implement a storage management
 *  Copyright (C) 2010  Daniel Pelaez, Daniel Lopez, Hector Hurtado
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.1-b02-fcs
 *  See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
 *  Any modifications to this file will be lost upon recompilation of the source schema.
 *  Generated on: 2002.01.01 at 01:28:54 AM COT
 */

package co.edu.uniquindio.dhash.node;

import co.edu.uniquindio.dhash.protocol.Protocol;
import co.edu.uniquindio.dhash.protocol.Protocol.*;
import co.edu.uniquindio.dhash.resource.ResourceAlreadyExistException;
import co.edu.uniquindio.dhash.resource.ResourceNotFoundException;
import co.edu.uniquindio.dhash.resource.SerializableResource;
import co.edu.uniquindio.dhash.resource.checksum.ChecksumeCalculator;
import co.edu.uniquindio.dhash.resource.persistence.PersistenceManager;
import co.edu.uniquindio.dhash.resource.serialization.SerializationHandler;
import co.edu.uniquindio.overlay.OverlayException;
import co.edu.uniquindio.overlay.OverlayNode;
import co.edu.uniquindio.storage.StorageException;
import co.edu.uniquindio.storage.StorageNode;
import co.edu.uniquindio.storage.resource.Resource;
import co.edu.uniquindio.utils.communication.Observable;
import co.edu.uniquindio.utils.communication.message.BigMessage;
import co.edu.uniquindio.utils.communication.message.BigMessageXML;
import co.edu.uniquindio.utils.communication.message.Message;
import co.edu.uniquindio.utils.communication.message.MessageXML;
import co.edu.uniquindio.utils.communication.transfer.CommunicationManager;
import co.edu.uniquindio.utils.hashing.Key;
import org.apache.log4j.Logger;

import java.util.Set;

/**
 * The {@code DHashNode} class implements the services of {@code put} and
 * {@code get} of a specific resource.
 *
 * @author Daniel Pelaez
 * @author Hector Hurtado
 * @author Daniel Lopez
 * @version 1.0, 17/06/2010
 * @since 1.0
 */
public class DHashNode implements StorageNode {
    private static final Logger logger = Logger
            .getLogger(DHashNode.class);

    private CommunicationManager communicationManager;
    private OverlayNode overlayNode;
    private int replicationFactor;
    private String name;
    private SerializationHandler serializationHandler;
    private ChecksumeCalculator checksumeCalculator;
    private PersistenceManager persistenceManager;

    public DHashNode(OverlayNode overlayNode, int replicationFactor, String name, CommunicationManager communicationManager, SerializationHandler serializationHandler, ChecksumeCalculator checksumeCalculator, PersistenceManager persistenceManager) {
        this.overlayNode = overlayNode;
        this.replicationFactor = replicationFactor;
        this.name = name;
        this.communicationManager = communicationManager;
        this.serializationHandler = serializationHandler;
        this.checksumeCalculator = checksumeCalculator;
        this.persistenceManager = persistenceManager;
    }

    /*
     * (non-Javadoc)
     *
     * @see co.edu.uniquindio.storage.StorageNode#get(java.lang.String)
     */
    public Resource get(String resourceKey) throws StorageException {

        Key key = new Key(resourceKey);
        Key lookupKey = overlayNode.lookUp(key);
        Message getMessage;
        Message resourceTransferMessage;

        if (lookupKey == null) {
            logger.error("Imposible to do get to resource: " + resourceKey
                    + " in this moment");
            throw new StorageException(
                    "Imposible to do get to resource, lookup fails");
        }

        getMessage = new MessageXML(Protocol.GET, lookupKey.getValue(), name);
        getMessage.addParam(GetParams.RESOURCE_KEY.name(), resourceKey);

        Boolean hasResource = communicationManager.sendMessageUnicast(getMessage,
                Boolean.class);

        if (hasResource) {

            resourceTransferMessage = new MessageXML(
                    Protocol.RESOURCE_TRANSFER, lookupKey.getValue(), name);
            resourceTransferMessage.addParam(
                    ResourceTransferParams.RESOURCE_KEY.name(), resourceKey);

            BigMessage resource = communicationManager
                    .recieverBigMessage(resourceTransferMessage);

            return serializationHandler.decode(resourceKey, resource
                    .getData(ResourceTransferResponseData.RESOURCE.name()));

        } else {
            ResourceNotFoundException resourceNotFoundException = new ResourceNotFoundException(
                    "Resource '" + resourceKey + "' not found");

            logger.warn("The resource '" + resourceKey + "' was not found");

            throw resourceNotFoundException;
        }

    }

    /*
     * (non-Javadoc)
     *
     * @see
     * co.edu.uniquindio.storage.StorageNode#put(co.edu.uniquindio.storage.resource
     * .Resource)
     */
    public void put(Resource resource) throws StorageException {

        Key key = new Key(resource.getKey());

        logger.debug("Resource to put: [" + resource.getKey() + "] Hashing: ["
                + key.getStringHashing() + "]");

        Key lookupKey = overlayNode.lookUp(key);

        if (lookupKey == null) {

            logger.error("Imposible to do put to resource: "
                    + resource.getKey() + " in this moment");
            throw new StorageException("Imposible to do put to resource: "
                    + resource.getKey() + " in this moment");
        }

        logger.debug("Lookup key for " + key.getStringHashing() + ": ["
                + lookupKey.getValue() + "]");

        put(resource, lookupKey, true);
    }

    /**
     * Replicates the specified file in its successors.
     *
     * @param resource The specified {@link SerializableResource} to replicate.
     * @throws ResourceAlreadyExistException
     * @throws OverlayException
     */
    public void replicateData(Resource resource)
            throws ResourceAlreadyExistException, OverlayException {
        Key[] succesorList = overlayNode.getNeighborsList();

        for (int i = 0; i < Math.min(replicationFactor, succesorList.length); i++) {
            logger
                    .debug("Replicate File: [" + resource.getKey()
                            + "] Hashing: ["
                            + succesorList[i].getStringHashing() + "]");
            logger.debug("Replicate to " + succesorList[i].getStringHashing());

            put(resource, succesorList[i], false);
        }
    }

    /**
     * Puts the specified resource into the network.
     *
     * @param resource  The resource to put.
     * @param lookupKey The key where the file will be put.
     * @param replicate Determines if the file will be replicated.
     * @throws ResourceAlreadyExistException
     */
    void put(Resource resource, Key lookupKey, boolean replicate)
            throws ResourceAlreadyExistException {

        Message resourceCompareMessage;
        BigMessage putMessage;

        resourceCompareMessage = new MessageXML(Protocol.RESOURCE_COMPARE,
                lookupKey.getValue(), name);
        resourceCompareMessage.addParam(ResourceCompareParams.CHECK_SUM.name(),
                checksumeCalculator.calculate(resource));
        resourceCompareMessage.addParam(ResourceCompareParams.RESOURCE_KEY
                .name(), resource.getKey());

        Boolean existResource = communicationManager.sendMessageUnicast(
                resourceCompareMessage, Boolean.class);

        if (existResource) {
            throw new ResourceAlreadyExistException("Resource existe yet");
        }

        putMessage = new BigMessageXML(Protocol.PUT, lookupKey.getValue(), name);
        putMessage.addParam(PutParams.RESOURCE_KEY.name(), resource.getKey());
        putMessage.addParam(PutParams.REPLICATE.name(), String
                .valueOf(replicate));
        putMessage
                .addData(PutDatas.RESOURCE.name(), serializationHandler.encode(resource));

        communicationManager.sendBigMessage(putMessage);

    }

    /**
     * Relocates the resources of the node.
     *
     * @param key The node where the files will be relocated.
     * @throws ResourceAlreadyExistException
     */
    public void relocateAllResources(Key key)
            throws ResourceAlreadyExistException {

        Set<String> resourcesNames = persistenceManager.getAllKeys();

        logger.info("Relocating Files...");
        logger.debug("Number of files: [" + resourcesNames.size() + "]");
        int filesRelocated = 0;

        for (String name : resourcesNames) {
            Resource resource = persistenceManager.find(name);

            Key fileKey = getFileKey(name);

            if (!fileKey.isBetween(key, overlayNode.getKey())) {
                put(resource, key, false);

                filesRelocated++;
            }
        }

        logger.info("Files relocated: [" + filesRelocated + "]");
    }

    Key getFileKey(String name) {
        return new Key(name);
    }

    /*
     * (non-Javadoc)
     *
     * @see co.edu.uniquindio.storage.StorageNode#leave()
     */
    public void leave() throws StorageException {
        try {
            Key[] key = overlayNode.leave();

            Set<String> resourcesNames = persistenceManager.getAllKeys();

            logger.info("Leaving...");
            logger.debug("Number of files to transfer: ["
                    + resourcesNames.size() + "]");

            if (!key.equals(overlayNode.getKey())) {
                for (String name : resourcesNames) {
                    Resource resource = persistenceManager.find(name);

                    put(resource, key[0], false);
                }
            }

            persistenceManager.deleteAll();

            communicationManager.removeObserver(overlayNode.getKey().getValue());
        } catch (OverlayException e) {
            logger.error("Error while leaving dhash node: '"
                    + overlayNode.getKey().toString() + "'");
        } catch (ResourceAlreadyExistException e) {
            logger.error("Error while leaving dhash node: '"
                    + overlayNode.getKey().toString() + "'");
        } catch (StorageException e) {
            logger.error("Error while leaving dhash node: '"
                    + overlayNode.getKey().toString() + "'");
        }

    }

    /**
     * Gets the key of the dht node.
     *
     * @return The {@link Key} of the dht node.
     */
    public String getName() {
        return name;
    }

    /**
     * Gets observable object
     */
    public Observable<Object> getObservable() {
        return null;
    }
}
