/*
 *  DHash project implement a storage management 
 *  Copyright (C) 2010  Daniel Pelaez, Daniel Lopez, Hector Hurtado
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *  
 *  This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.1-b02-fcs 
 *  See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
 *  Any modifications to this file will be lost upon recompilation of the source schema. 
 *  Generated on: 2002.01.01 at 01:28:54 AM COT 
 */

package co.edu.uniquindio.dhash.node;

import java.io.IOException;
import java.util.Set;

import co.edu.uniquindio.dhash.configurations.DHashProperties;
import co.edu.uniquindio.dhash.protocol.Protocol;
import co.edu.uniquindio.dhash.protocol.Protocol.GetParams;
import co.edu.uniquindio.dhash.protocol.Protocol.PutDatas;
import co.edu.uniquindio.dhash.protocol.Protocol.PutParams;
import co.edu.uniquindio.dhash.protocol.Protocol.ResourceCompareParams;
import co.edu.uniquindio.dhash.protocol.Protocol.ResourceTransferParams;
import co.edu.uniquindio.dhash.protocol.Protocol.ResourceTransferResponseData;
import co.edu.uniquindio.dhash.resource.ResourceAlreadyExistException;
import co.edu.uniquindio.dhash.resource.ResourceManager;
import co.edu.uniquindio.dhash.resource.ResourceNotFoundException;
import co.edu.uniquindio.overlay.OverlayException;
import co.edu.uniquindio.overlay.OverlayNode;
import co.edu.uniquindio.storage.StorageException;
import co.edu.uniquindio.storage.StorageNode;
import co.edu.uniquindio.storage.resource.Resource;
import co.edu.uniquindio.storage.resource.ResourceException;
import co.edu.uniquindio.storage.resource.SerializableResource;
import co.edu.uniquindio.utils.communication.Observable;
import co.edu.uniquindio.utils.communication.message.BigMessage;
import co.edu.uniquindio.utils.communication.message.BigMessageXML;
import co.edu.uniquindio.utils.communication.message.Message;
import co.edu.uniquindio.utils.communication.message.MessageXML;
import co.edu.uniquindio.utils.communication.transfer.CommunicationManager;
import co.edu.uniquindio.utils.communication.transfer.CommunicationManagerCache;
import co.edu.uniquindio.utils.hashing.Key;
import co.edu.uniquindio.utils.logger.LoggerDHT;

/**
 * The {@code DHashNode} class implements the services of {@code put} and
 * {@code get} of a specific resource.
 * 
 * @author Daniel Pelaez
 * @author Hector Hurtado
 * @author Daniel Lopez
 * @version 1.0, 17/06/2010
 * @since 1.0
 */
public class DHashNode implements StorageNode {

	/**
	 * Logger
	 */
	private static final LoggerDHT logger = LoggerDHT
			.getLogger(DHashNode.class);

	/**
	 * Communication manager
	 */
	private CommunicationManager communicationManager;

	/**
	 * this is the reference of the dht node that will be used for the dhash
	 * node.
	 */
	private OverlayNode overlayNode;

	/**
	 * This is the object used for saving an getting the files.
	 */
	private ResourceManager objectManager;

	/**
	 * This is the value of the number of copies in the successors made from a
	 * PUT.
	 */
	private int replicationFactor;

	/**
	 * Node name
	 */
	private String name;

	/**
	 * Overlay observer
	 */
	private OverlayObserver overlayObserver;

	/**
	 * The constructor of the class. Sets the reference of the dhtNode and
	 * initializes the objectManager and the replicationFactor.
	 * 
	 * @param overlayNode
	 *            The reference of the dhtNode.
	 * @param name
	 *            The name of the node.
	 */
	public DHashNode(OverlayNode overlayNode, String name) {
		this.overlayNode = overlayNode;
		this.overlayObserver = OverlayObserver.getInstance(DHashProperties
				.getInstance().getOverlay().getObserverClass());
		this.overlayObserver.setDHashNode(this);
		this.overlayNode.getObservable().addObserver(overlayObserver);
		this.objectManager = new ResourceManager(name);
		this.replicationFactor = DHashProperties.getInstance().getReplication()
				.getAmount();
		this.name = name;
		this.communicationManager = CommunicationManagerCache
				.getCommunicationManager(DHashNodeFactory.DHASH);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see co.edu.uniquindio.storage.StorageNode#get(java.lang.String)
	 */
	public Resource get(String resourceKey) throws StorageException {

		Key key = new Key(resourceKey);
		Key lookupKey = overlayNode.lookUp(key);
		Message getMessage;
		Message resourceTransferMessage;

		if (lookupKey == null) {
			logger.error("Imposible to do get to resource: " + resourceKey
					+ " in this moment");
			throw new StorageException(
					"Imposible to do get to resource, lookup fails");
		}

		getMessage = new MessageXML(Protocol.GET, lookupKey.getValue(), name);
		getMessage.addParam(GetParams.RESOURCE_KEY.name(), resourceKey);

		Boolean hasResource = communicationManager.sendMessageUnicast(getMessage,
				Boolean.class);

		if (hasResource) {

			resourceTransferMessage = new MessageXML(
					Protocol.RESOURCE_TRANSFER, lookupKey.getValue(), name);
			resourceTransferMessage.addParam(
					ResourceTransferParams.RESOURCE_KEY.name(), resourceKey);

			BigMessage resource = communicationManager
					.recieverBigMessage(resourceTransferMessage);

			try {
				return SerializableResource.valueOf(resource
						.getData(ResourceTransferResponseData.RESOURCE.name()));
			} catch (IOException e) {
				throw new ResourceException(
						"Error to parser resource response", e);
			} catch (ClassNotFoundException e) {
				throw new ResourceException(
						"Error to parser resource response", e);
			}

		} else {
			ResourceNotFoundException resourceNotFoundException = new ResourceNotFoundException(
					"Resource '" + resourceKey + "' not found");

			logger.warn("The resource '" + resourceKey + "' was not found");

			throw resourceNotFoundException;
		}

	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * co.edu.uniquindio.storage.StorageNode#put(co.edu.uniquindio.storage.resource
	 * .Resource)
	 */
	public void put(Resource resource) throws StorageException {

		Key key = new Key(resource.getKey());

		logger.fine("Resource to put: [" + resource.getKey() + "] Hashing: ["
				+ key.getStringHashing() + "]");

		Key lookupKey = overlayNode.lookUp(key);

		if (lookupKey == null) {

			logger.error("Imposible to do put to resource: "
					+ resource.getKey() + " in this moment");
			throw new StorageException("Imposible to do put to resource: "
					+ resource.getKey() + " in this moment");
		}

		logger.fine("Lookup key for " + key.getStringHashing() + ": ["
				+ lookupKey.getValue() + "]");

		put(resource, lookupKey, true);
	}

	/**
	 * Replicates the specified file in its successors.
	 * 
	 * @param resource
	 *            The specified {@link SerializableResource} to replicate.
	 * @throws ResourceAlreadyExistException
	 * @throws OverlayException
	 */
	public void replicateData(Resource resource)
			throws ResourceAlreadyExistException, OverlayException {
		Key[] succesorList = overlayNode.getNeighborsList();

		for (int i = 0; i < Math.min(replicationFactor, succesorList.length); i++) {
			logger
					.fine("Replicate File: [" + resource.getKey()
							+ "] Hashing: ["
							+ succesorList[i].getStringHashing() + "]");
			logger.finest("Replicate to " + succesorList[i].getStringHashing());

			put(resource, succesorList[i], false);
		}
	}

	/**
	 * Puts the specified resource into the network.
	 * 
	 * @param resource
	 *            The resource to put.
	 * @param lookupKey
	 *            The key where the file will be put.
	 * @param replicate
	 *            Determines if the file will be replicated.
	 * @throws ResourceAlreadyExistException
	 */
	private void put(Resource resource, Key lookupKey, boolean replicate)
			throws ResourceAlreadyExistException {

		Message resourceCompareMessage;
		BigMessage putMessage;

		resourceCompareMessage = new MessageXML(Protocol.RESOURCE_COMPARE,
				lookupKey.getValue(), name);
		resourceCompareMessage.addParam(ResourceCompareParams.CHECK_SUM.name(),
				resource.getCheckSum());
		resourceCompareMessage.addParam(ResourceCompareParams.RESOURCE_KEY
				.name(), resource.getKey());

		Boolean existResource = communicationManager.sendMessageUnicast(
				resourceCompareMessage, Boolean.class);

		if (existResource) {
			throw new ResourceAlreadyExistException("Resource existe yet");
		}

		putMessage = new BigMessageXML(Protocol.PUT, lookupKey.getValue(), name);
		putMessage.addParam(PutParams.RESOURCE_KEY.name(), resource.getKey());
		putMessage.addParam(PutParams.REPLICATE.name(), String
				.valueOf(replicate));
		putMessage
				.addData(PutDatas.RESOURCE.name(), resource.getSerializable());

		communicationManager.sendBigMessage(putMessage);

	}

	/**
	 * Gets the objectManager.
	 * 
	 * @return The reference of the {@link ResourceManager}.
	 */
	public ResourceManager getObjectManager() {
		return objectManager;
	}

	/**
	 * Relocates the resources of the node.
	 * 
	 * @param key
	 *            The node where the files will be relocated.
	 * @throws ResourceAlreadyExistException
	 */
	public void relocateAllResources(Key key)
			throws ResourceAlreadyExistException {

		Set<String> resourcesNames = objectManager.getResourcesNames();

		logger.info("Relocating Files...");
		logger.fine("Number of files: [" + resourcesNames.size() + "]");
		int filesRelocated = 0;

		for (String name : resourcesNames) {
			Resource resource = objectManager.get(name);

			Key fileKey = new Key(name);

			if (!fileKey.isBetween(key, overlayNode.getKey())) {
				put(resource, key, false);

				filesRelocated++;
			}
		}

		logger.info("Files relocated: [" + filesRelocated + "]");
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see co.edu.uniquindio.storage.StorageNode#leave()
	 */
	public void leave() throws StorageException {
		try {
			Key[] key = overlayNode.leave();

			Set<String> resourcesNames = objectManager.getResourcesNames();

			logger.info("Leaving...");
			logger.fine("Number of files to transfer: ["
					+ resourcesNames.size() + "]");

			if (!key.equals(overlayNode.getKey())) {
				for (String name : resourcesNames) {
					Resource resource = objectManager.get(name);

					put(resource, key[0], false);
				}
			}

			objectManager.deleteResources();

			DHashNodeFactory.getInstance().destroyNode(
					overlayNode.getKey().getValue());

		} catch (DHashFactoryException e) {
			logger.error("Error while leaving dhash node: '"
					+ overlayNode.getKey().toString() + "'");
			logger.fatal("Error while leaving dhash node: '"
					+ overlayNode.getKey().toString() + "'", e);
		} catch (OverlayException e) {
			logger.error("Error while leaving dhash node: '"
					+ overlayNode.getKey().toString() + "'");
		} catch (ResourceAlreadyExistException e) {
			logger.error("Error while leaving dhash node: '"
					+ overlayNode.getKey().toString() + "'");
		} catch (StorageException e) {
			logger.error("Error while leaving dhash node: '"
					+ overlayNode.getKey().toString() + "'");
		}

	}

	/**
	 * Gets the key of the dht node.
	 * 
	 * @return The {@link Key} of the dht node.
	 */
	public String getName() {
		return name;
	}

	/**
	 * Gets observable object
	 */
	public Observable<Object> getObservable() {
		return null;
	}
}
